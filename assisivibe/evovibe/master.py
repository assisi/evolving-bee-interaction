#!/usr/bin/env python
# -*- coding: utf-8 -*-

import config
import episode
import evaluator
import chromosome
import worker
import continue_inspyred

import inspyred

import argparse
import os
import csv
import random
import subprocess

import assisivibe.common.arena as arena
import assisivibe.common.util as util
import assisivibe.common.worker_settings as worker_settings
import assisivibe.common.zmq_sock_utils as zmq_sock_utils

import worker

FIT_GENERATION = 0
FIT_FITNESS = 1
FIT_CHROMOSOME_GENES = 2

class EvovibeWorkerStub (worker_settings.BasicWorkerStub):
    def __init__ (self, casu_number, socket):
        worker_settings.BasicWorkerStub.__init__ (self, casu_number, socket)

    def initialise (self, config):
        print ("Initializing worker responsible for casu #%d..." % (self.casu_number))
        answer = zmq_sock_utils.send_recv (self.socket, [
            worker.INITIALISE,
            config.frames_per_second,
            config.evaluation_proceeding,
            config.has_blip,
            config.chromosome_type])
        print ("Worker responded with: %s" % (str (answer)))
        return (self.casu_number, self)

    def terminate_session (self):
        """
        Terminate the session with the worker, which causes the worker process to finish.
        """
        print ("Sending terminate command to worker responsible for casu #%d..." % (self.casu_number))
        answer = zmq_sock_utils.send_recv (self.socket, [worker.TERMINATE])
        print ("Worker responded with: %s" % (str (answer)))

def parse_arguments ():
    """
    Parse the command line arguments.
    """
    parser = argparse.ArgumentParser (
        description = 'Incremental Evolution of vibration models to aggregate bees.',
        argument_default = None
    )
    parser.add_argument (
        '--config',
        default = 'config2',
        type = str,
        help = 'configuration file to use')
    parser.add_argument (
        '--command', '-c',
        default = None,
        type = str,
        help = 'what should we do?\n\tnew-run: perform a new experimental run\n\tcontinue-run: continue a previous run')
    parser.add_argument (
        '--run', '-r',
        default = None,
        type = int,
        help = "run number to use")
    parser.add_argument (
        '--debug',
        action = 'store_true',
        help = "enable debug mode")
    parser.add_argument (
        '--deploy',
        action = 'store_true',
        help = "deploy the workers automatically")
    parser.add_argument (
        '--workers',
        default = 'workers',
        type = str,
        help = 'worker settings file to load')
    return parser.parse_args ()

def run_pylon_config (config, experiment_folder):
    filename = os.path.join (os.path.dirname (os.path.dirname (os.path.dirname (os.path.abspath (__file__)))), 'pylon/pylonconfig')
    return_code = subprocess.call ([
        filename,
        '--frame-rate', "%f" % (config.frames_per_second),
        '--output-folder', experiment_folder])
    if return_code != 0:
        sys.exit (return_code)
    print ('Pylon camera is configured.')
    raw_input ('Press ENTER to continue')

def calculate_experiment_folder_for_new_run (args):
    """
    Compute the experiment folder for a new experimental run.
    This folder is where all the files generated by an experimental run are stored.
    """
    run_number = 1
    while True:
        result = 'run-%03d/' % (run_number)
        if args.debug or not os.path.isdir (result) and not os.path.exists (result):
            return result
        run_number += 1

def create_directories_for_experimental_run (experiment_folder, args):
    """
    Create the directories for an experimental run.
    """
    for path in [
            experiment_folder,
            experiment_folder + "logs/",
            experiment_folder + "episodes/"]:
        try:
            os.makedirs (path)
        except:
            if not args.debug:
                raise

def create_experimental_run_files (config, experiment_folder):
    """
    Create the files that are going to store the data produced by an experimental run.
    The data is stored in CSV files.  The files are initialized with a header row.
    """
    with open (experiment_folder + "population2.csv", 'w') as fp:
        f = csv.writer (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
        row = ["generation"] + [gene.name for gene in chromosome.CHROMOSOME_METHODS [config.chromosome_type].get_genes ()]
        f.writerow (row)
        fp.close ()
    with open (experiment_folder + "evaluation2.csv", 'w') as fp:
        f = csv.writer (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
        row = ["generation", "episode", "iteration", "selected_arena", "active_casu", "timestamp", "value"] + [gene.name for gene in chromosome.CHROMOSOME_METHODS [config.chromosome_type].get_genes ()]
        f.writerow (row)
        fp.close ()
    with open (experiment_folder + "fitness2.csv", 'w') as fp:
        f = csv.writer (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
        row = ["generation", "fitness"] + [gene.name for gene in chromosome.CHROMOSOME_METHODS [config.chromosome_type].get_genes ()]
        f.writerow (row)
        fp.close ()
    with open (experiment_folder + "partial2.csv", 'w') as fp:
        f = csv.writer (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
        row = ["generation", "episode", "fitness"] + [gene.name for gene in chromosome.CHROMOSOME_METHODS [config.chromosome_type].get_genes ()]
        f.writerow (row)
        fp.close ()

def check_run (args):
    run_number = args.run
    result = 'run-%03d/' % (run_number)
    if os.path.isdir (result):
        return result
    else:
        print ("There is no run ", run_number)
        sys.exit (1)

def population_to_continue (config, experiment_folder):
    number_genes = len (chromosome.CHROMOSOME_METHODS [config.chromosome_type].get_genes ())
    with open (experiment_folder + "population2.csv", "r") as fp:
        f = csv.reader (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
        f.next () #skip header_row
        rows_population = [row for row in f]
        fp.close ()
    if len (rows_population) > config.population_size:
        with open (os.path.join (experiment_folder, "fitness2.csv"), 'r') as fp:
            f = csv.reader (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
            f.next () # skip header row
            rows_fitness = [row for row in f]
            fp.close ()
        population_parents = [r [FIT_CHROMOSOME_GENES:(FIT_CHROMOSOME_GENES + number_genes)] for r in rows_fitness [-config.population_size:]]
        population_offsprings = [r [evaluator.POP_CHROMOSOME_GENES:(evaluator.POP_CHROMOSOME_GENES + number_genes)] for r in rows_population [-config.population_size:]]
        n = len (population_offsprings [0])
        [c.extend ([random.random () for _ in xrange (n)]) for c in population_offsprings]
    else:
        population_parents    = [r [evaluator.POP_CHROMOSOME_GENES:(evaluator.POP_CHROMOSOME_GENES + number_genes)] for r in rows_population [-config.population_size:]]
        population_offsprings = []
    # convert all genes to integers
    population_parents    = [[int (g) for g in c] for c in population_parents]
    population_offsprings = [[int (g) for g in c] for c in population_offsprings]
    last_generation = int (rows_population [-1][evaluator.POP_GENERATION])
    return (population_parents, population_offsprings, last_generation)

def fitness_to_continue (config, experiment_folder):
    with open (experiment_folder + "partial2.csv", "r") as fp:
        f = csv.reader (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
        f.next () #skip header_row
        rows_partial = [row for row in f]
        fp.close ()
    with open (experiment_folder + "fitness2.csv", "r") as fp:
        f = csv.reader (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
        f.next () #skip header_row
        rows_fitness = [row for row in f]
        fp.close ()
    if rows_partial == []:
        last_generation_number = 0
        last_episode_number = 0
        parents_fitness   = []
        offspring_fitness = []
    else:
        last_generation_number = int (rows_partial [-1][evaluator.PRT_GENERATION])
        last_episode_number = int (rows_partial [-1][evaluator.PRT_EPISODE])
        if last_generation_number > 0:
            parents_fitness   = [r[FIT_FITNESS] for r in rows_fitness if r[FIT_GENERATION] == last_generation_number - 1]
            offspring_fitness = [r[evaluator.PRT_FITNESS] for r in rows_partial if r[evaluator.PRT_GENERATION] == last_generation_number]
        else:
            parents_fitness   = [r[evaluator.PRT_FITNESS] for r in rows_partial if r[evaluator.PRT_GENERATION] == last_generation_number]
            offspring_fitness = []
    return (parents_fitness, offspring_fitness, last_generation_number, last_episode_number)

def fitness_save_observer (population, num_generations, num_evaluations, args):
    """
    Observer passed to inspyred evolutionary algorithm to save the data to file fitness2.csv.
    """
    config_experiment_folder = args ['config_experiment_folder']
    with open (config_experiment_folder + "fitness2.csv", 'a') as fp:
        f = csv.writer (fp, delimiter = ',', quoting = csv.QUOTE_NONE, quotechar = '"')
        for individual in population:
            row = [num_generations, individual.fitness] + individual.candidate
            f.writerow (row)
        fp.close ()

def user_termination (population, num_generations, num_evaluations, args):
    print ('Generation %d has finished.' % (num_generations))
    return util.is_answer_yes ('Do you want to terminate the program')

def initialise_data_for_inspyred (config, worker_stubs, experiment_folder, current_generation = 0, episode_index = 1):
    epsd = episode.Episode (config, worker_stubs, experiment_folder, episode_index)
    epsd.initialise ()
    evltr = evaluator.Evaluator (config, epsd, experiment_folder, current_generation)
    evolutionary_algorithm = inspyred.ec.ES (random.Random ())
    evolutionary_algorithm.terminator = [inspyred.ec.terminators.generation_termination, user_termination]
    evolutionary_algorithm.observer = [fitness_save_observer]
    evolutionary_algorithm.variator = [chromosome.CHROMOSOME_METHODS [config.chromosome_type].variator ()]
    generator = chromosome.CHROMOSOME_METHODS [config.chromosome_type].generator
    return (epsd, evltr, evolutionary_algorithm, generator)

def new_run (config, worker_stubs, experiment_folder):
    epsd, evltr, evolutionary_algorithm, generator = initialise_data_for_inspyred (config, worker_stubs, experiment_folder)
    evolutionary_algorithm.evolve (
        generator = generator,
        evaluator = evltr.population_evaluator,
        pop_size = config.population_size,
        bounder = None,
        maximize = True,
        max_generations = config.number_generations,
        config_experiment_folder = experiment_folder
    )
    epsd.finish (True)
    terminate_workers_get_data (worker_stubs, experiment_folder)
    print ("Evolutionary Strategy algorithm finished!")

def continue_run (config, worker_stubs, experiment_folder):
    number_genes = len (chromosome.CHROMOSOME_METHODS [config.chromosome_type].get_genes ())
    rows_partial = util.load_csv (experiment_folder + "partial2.csv", True)
    rows_fitness = util.load_csv (experiment_folder + "fitness2.csv", True)
    rows_population = util.load_csv (experiment_folder + "population2.csv", True)
    # where are we?
    if len (rows_partial) < config.population_size or \
        rows_partial [-1][evaluator.PRT_GENERATION] != rows_fitness [-config.population_size][evaluator.PRT_GENERATION]:
        if len (rows_partial) < config.population_size:
            # in the initial population
            last_generation_number = int (rows_partial [-1][evaluator.PRT_GENERATION])
            last_episode_number = int (rows_partial [-1][evaluator.PRT_EPISODE])
            parents_pop = [r [evaluator.POP_CHROMOSOME_GENES:] for r in rows_population]
            parents_fit = [r [evaluator.PRT_FITNESS] for r in rows_fitness]
            offspring_pop = []
            offspring_fit = []
        else:
            # in the middle of a generation
            last_generation_number = int (rows_partial [-1][evaluator.PRT_GENERATION])
            last_episode_number = int (rows_partial [-1][evaluator.PRT_EPISODE])
            parents_pop = [r [FIT_CHROMOSOME_GENES:(FIT_CHROMOSOME_GENES + number_genes)] for r in rows_fitness if r [FIT_GENERATION] == last_generation_number - 1]
            parents_fit = [r [FIT_FITNESS] for r in rows_fitness if r [FIT_GENERATION] == last_generation_number - 1]
            offspring_pop = [r [evaluator.POP_CHROMOSOME_GENES:] for r in rows_population [-config.population_size:]]
            offspring_fit = [r [evaluator.PRT_FITNESS] for r in rows_partial if r [evaluator.PRT_GENERATION] == last_generation_number]
    else:
        # at the start of a generation
        last_generation_number = int (rows_partial [-1][evaluator.PRT_GENERATION])
        current_generation_number = int (rows_partial [-1][evaluator.PRT_GENERATION]) + 1
        last_episode_number = int (rows_partial [-1][evaluator.PRT_EPISODE])
        parents_pop = [r [FIT_CHROMOSOME_GENES:(FIT_CHROMOSOME_GENES + number_genes)] for r in rows_fitness [-config.population_size:]]
        parents_fit = [r [FIT_FITNESS] for r in rows_fitness [-config.population_size:]]
        offspring_pop = []
        offspring_fit = []
    # convert genes to integers
    parents_pop = [[int (g) for g in c] for c in parents_pop]
    offspring_pop = [[int (g) for g in c] for c in offspring_pop]
    # report and GO
    report_previous_run_data (parents_pop, offspring_pop, last_generation_number, parents_fit, offspring_fit, last_episode_number)
    epsd, evltr, evolutionary_algorithm, generator = initialise_data_for_inspyred (
        config, worker_stubs, experiment_folder,
        current_generation_number,
        last_episode_number + 1)
    continue_inspyred.continue_evolution (
        evolutionary_algorithm,
        population_parents = parents_pop,
        population_offsprings = offspring_pop,
        parents_fitness = parents_fit,
        offspring_fitness = offspring_fit,
        generator = generator,
        evaluator = evltr.population_evaluator,
        number_generations = last_generation_number,
        maximize = True,
        bounder = None,
        max_generations = max (0, config.number_generations - last_generation_number),
        config_experiment_folder = experiment_folder
        )
    epsd.finish (True)
    terminate_workers_get_data (worker_stubs, experiment_folder)
    print ("Evolutionary Strategy algorithm finished!")

def report_previous_run_data (population_parents, population_offsprings, last_generation_number, parents_fitness, offspring_fitness, last_episode_number):
    print ("\n\n* ** Previous Run Data ** *")
    for l, c, f in [('parents', population_parents, parents_fitness), ('offspring', population_offsprings, offspring_fitness)]:
        print ("  population " + l)
        if c == []:
            print ("    EMPTY")
        else:
            for index in xrange (len (c)):
                if index < len (f):
                    fs = "%7.1f" % f [index]
                else:
                    fs = "       "
                cs = ''
                for g in c [index]:
                    if cs != '':
                        cs = '%s , ' % cs
                    cs = '%s%7d' % (cs, g)
                print ("    %s  [ %s ]" % (fs, cs))
    print "  last generation", last_generation_number
    print "  last episode", last_episode_number
    raw_input ("Press ENTER to continue")

def terminate_workers_get_data (worker_stubs, experiment_folder):
    for ws in worker_stubs.values ():
        ws.terminate_session ()
    worker_settings.collect_data_from_workers (worker_stubs.values (), experiment_folder + "logs")

def main ():
    try:
        os.makedirs ("tmp")
    except OSError:
        pass
    args = parse_arguments ()
    if args.command in ['new-run', 'new_run']:
        cfg = config.Config (args.config)
        cfg.status ()
        worker_stubs = worker_settings.connect_workers (worker_settings.load_worker_settings (args.workers), EvovibeWorkerStub)
        for evws in worker_stubs.values ():
            evws.initialise (cfg)
        experiment_folder = calculate_experiment_folder_for_new_run (args)
        create_directories_for_experimental_run (experiment_folder, args)
        run_pylon_config (cfg, experiment_folder)
        create_experimental_run_files (cfg, experiment_folder)
        new_run (cfg, worker_stubs, experiment_folder)
    elif args.command in ['continue-run', 'continue_run']:
        cfg = config.Config (args.config)
        cfg.status ()
        experiment_folder = check_run (args)
        run_pylon_config (cfg, experiment_folder)
        worker_stubs = worker_settings.connect_workers (worker_settings.load_worker_settings (args.workers), EvovibeWorkerStub)
        for evws in worker_stubs.values ():
            evws.initialise (cfg)
        continue_run (cfg, worker_stubs, experiment_folder)
    elif args.command in ['deploy']:
        for afile in  [
            os.path.join (os.path.dirname (os.path.abspath (__file__)), 'chromosome.py'),
            os.path.join (os.path.dirname (os.path.dirname (os.path.abspath (__file__))), 'common/segments.py'),
            os.path.join (os.path.dirname (os.path.dirname (os.path.abspath (__file__))), 'common/zmq_sock_utils.py')
        ]:
            print (afile)
        worker_settings.deploy_workers (args.workers, os.path.join (os.path.dirname (os.path.abspath (__file__)), 'worker.py'), [
            os.path.join (os.path.dirname (os.path.abspath (__file__)), 'chromosome.py'),
            os.path.join (os.path.dirname (os.path.dirname (os.path.abspath (__file__))), 'common/segments.py'),
            os.path.join (os.path.dirname (os.path.dirname (os.path.abspath (__file__))), 'common/zmq_sock_utils.py')
        ]
        )
    elif args.command == None:
        print ("Nothing to do!\n")
    else:
        print ("Unknown command: %s" % args.command)

if __name__ == '__main__':
    main ()
